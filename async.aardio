//异步的promise
namespace promise.async
import promise;
import thread.command;
import thread.manage;
import win.ui;

listener = thread.command()
manage = thread.manage(20) //线程池
//线程函数
var threadCall =function(guidResolve,guidreject,cratePromiseFun,args){
	import promise;
	function sucess(...){
		//成功
		thread.command.post(guidResolve,thread.getHandle(),...)
	}
	function fail(...){
		//失败
		thread.command.post(guidreject,thread.getHandle(),...)
	}
	cratePromiseFun(args).then(sucess,fail)
			
}


//创建线程异步promise
function crate(cratePromiseFun,args){
    var args = {args}
    //参数判断
     if(type.function != type(cratePromiseFun)){
    	error("参数错误")
	}
   return ..promise(function(resolve,reject){
       try{
       		var guidResolve = tostring(win.guid.create())
			var guidreject = tostring(win.guid.create())
			//成功事件
    		listener[guidResolve] = function( threadHandle,... ){
		  		resolve(...)
		  		thread.waitClose(threadHandle)
			}
			//失败事件
			listener[guidreject] = function( threadHandle,...){
				reject(...)
		  		thread.waitClose(threadHandle)
			}
			//新建线程
		 	manage.create(threadCall/**线程函数**/,guidResolve,guidreject,cratePromiseFun/**runturn promise fun**/,args/**cratePromiseFun args**/)
       }
       catch(e){
       		reject(e)
       }
       
	
	}); 
}



/**intellisense(promise.async)
crate() = !promise. 
crate(createPromiseFun) = 创建并返回异步Promise，参数为一个线程安全的函数{
    返回值为一个promise:
    function createPromiseeFun(){
		return Promise(function(resolve,reject){
			sleep(100)
			resolve("createPromiseFun")
		});
	}

}
end intellisense**/

